<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>falch.me - Galaxian</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      height: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>
  <script>
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    let w, h;

    const spriteSheet = new Image();
    spriteSheet.src = 'sprites.png';

    const player = { x: 100, y: 0, width: 64, height: 64, speed: 4 };
    const playerSprite = { x: 1, y: 70, w: 16, h: 16 };
    const keys = {};
    const bullets = [];
    const enemyGrid = [];
    const spacing = 64;
    const enemySize = 64;
    const numParticles = 250;
    let particles = [];
    let tick = 0;
    let waveOffsetX = 0;
    let waveDir = 1;
    let enemiesCanAttack = false;
    let formation = []; 
    
    const enemySprites = {
      red: generateSprites({ x: 1, y: 1 }, 4, 6),
      blue: generateSprites({ x: 1, y: 35 }, 4, 6),
      purple: generateSprites({ x: 1, y: 18 }, 4, 6),
      yellow: {
        idle: [{ x: 1, y: 52, w: 16, h: 16 }],
        fly: Array.from({ length: 6 }, (_, i) => ({ x: 18 + i * 17, y: 52, w: 16, h: 16 })),
        explode: [61, 78, 95, 112].map(x => ({ x, y: 70, w: 16, h: 16 }))
      }
    };

    function generateSprites(start, idleCount, flyCount) {
      const spriteWidth = 16, spriteHeight = 16;
      const explode = [61, 78, 95, 112].map(x => ({ x, y: 70, w: spriteWidth, h: spriteHeight }));
      const idle = Array.from({ length: idleCount }, (_, i) => ({ x: start.x + i * 17, y: start.y, w: spriteWidth, h: spriteHeight }));
      const fly = Array.from({ length: flyCount }, (_, i) => ({ x: start.x + (idleCount + i) * 17, y: start.y, w: spriteWidth, h: spriteHeight }));
      return { idle, explode, fly };
    }

    function drawEnemies() {
      for (let i = enemyGrid.length - 1; i >= 0; i--) {
        const e = enemyGrid[i];
        if (updateEnemyState(e, i)) continue;
        drawEnemy(e);
      }
    }

    function updateEnemyState(e, index) {
      const sprites = enemySprites[e.type][e.state] || enemySprites[e.type].idle;
      switch (e.state) {
        case 'fly':
          return handleFlyState(e, index, sprites);
        case 'return':
          return handleReturnState(e, sprites);
        case 'enter':
          return handleEnterState(e, sprites);
        case 'idle':
          handleIdleState(e, sprites);
          break;
        case 'explode':
          return handleExplodeState(e, index, sprites);
      }
      return false;
    }

    function getAnimationFrame(e, sprites) {
      const dx = e.x - e.prevX;
      const dy = e.y - e.prevY;

      if (e.state === 'idle') {
        // Use "idle" frames (0–3) only for idle state
        return { frame: Math.floor((tick / 5) % 4), flipH: false, flipV: false };
      } else if (e.state === 'explode') {
        // Use explosion frames
        return { frame: Math.floor(e.frame), flipH: false, flipV: false };
      }

      // Map the angle of movement to the appropriate frame
      const angle = Math.atan2(dy, dx);
      let frame = 4; // Default to the first flight frame
      let flipH = false;

      if (angle >= -Math.PI / 4 && angle < Math.PI / 4) {
        // Moving right
        frame = 4;
      } else if (angle >= Math.PI / 4 && angle < (3 * Math.PI) / 4) {
        // Moving down (prioritize downward attack direction)
        frame = 6;
      } else if (angle >= (3 * Math.PI) / 4 || angle < -(3 * Math.PI) / 4) {
        // Moving left
        frame = 4;
        flipH = true;
      } else if (angle >= -(3 * Math.PI) / 4 && angle < -Math.PI / 4) {
        // Moving up
        frame = 6;
      }

      return { frame, flipH, flipV: false }; // Ensure no vertical flipping
    }

    function handleFlyState(e, index, sprites) {
      e.t += 0.02;

      e.prevX = e.x;
      e.prevY = e.y;

      if (e.type === 'yellow') {
        // Yellow enemy leads the attack with a swooping motion
        const dir = e.direction === 'left' ? -1 : 1;
        e.x = e.originX + dir * Math.sin(e.t * e.flyFreq * Math.PI) * e.flyAmp;
        e.y += 1.5; // Move downward

        const { frame, flipH, flipV } = getAnimationFrame(e, sprites);
        e.frame = frame;
        e.flipH = flipH;
        e.flipV = flipV;

        e.rotation = Math.atan2(e.y - e.prevY, e.x - e.prevX);

        // Update the positions of the red escorts following this yellow enemy
        const escorts = enemyGrid.filter(escort => escort.followYellow === e && escort.state === 'fly');
        escorts.forEach((escort, i) => {
          escort.x = e.x + (i === 0 ? -spacing : spacing); // Position escorts on either side
          escort.y = e.y + 40; // Slightly below the yellow enemy
          escort.rotation = e.rotation; // Match yellow's rotation
        });

        if (e.y > h + enemySize) {
          // Transition to "return" state and reset position above the screen
          e.state = 'return';
          e.y = -enemySize;
          e.x = e.originX;
          e.wasAttacking = false;

          // Reset escorts to their original positions
          escorts.forEach(escort => {
            escort.state = 'return';
            escort.wasAttacking = false;
            escort.followYellow = null; // Remove reference to the yellow enemy
            escort.y = -enemySize; // Start from above the screen
          });
        }

        return false;
      }

      if (e.followYellow) {
        // Dynamically follow the yellow enemy
        const yellow = e.followYellow;
        if (yellow && yellow.state === 'fly') {
          e.x = yellow.x + e.offsetX; // Follow yellow's x position with offset
          e.y = yellow.y + e.offsetY; // Follow yellow's y position with offset
          e.rotation = yellow.rotation; // Match yellow's rotation
        }
        return false;
      }

      // Handle other enemy types
      const dir = e.direction === 'left' ? -1 : 1;
      e.x = e.originX + dir * Math.sin(e.t * e.flyFreq * Math.PI) * e.flyAmp;
      e.y += 2;

      const { frame, flipH, flipV } = getAnimationFrame(e, sprites);
      e.frame = frame;
      e.flipH = flipH;
      e.flipV = flipV;

      e.rotation = Math.atan2(e.y - e.prevY, e.x - e.prevX);

      if (e.y > h + enemySize) {
        e.state = 'return';
        e.y = -enemySize;
        e.x = e.originX;
        e.wasAttacking = false;
      }

      return false;
    }

    function handleReturnState(e, sprites) {
      if (tick % 4 === 0) e.frame = (e.frame + 1) % sprites.length;

      // Gradually move the enemy back to its formation position
      const dx = (e.originX - e.x) * 0.1;
      const dy = (e.originY - e.y) * 0.1;
      e.x += dx;
      e.y += dy;

      // When the enemy is close to its formation position, snap to "idle"
      if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
        e.x = e.originX;
        e.y = e.originY;
        e.state = 'idle';
        e.frame = 0;

        // Reset rotation to face forward
        e.rotation = 0;
      }

      return false;
    }

    function handleEnterState(e, sprites) {
      if (tick % 3 === 0) e.frame = (e.frame + 1) % sprites.length;
      e.t += 0.04;
      e.x = e.originX + Math.sin(e.t * 2) * 150;
      e.y = -100 + e.t * 100;
      if (e.y >= e.originY) {
        e.y = e.originY;
        e.x = e.originX;
        e.state = 'idle';
        e.frame = 0;
      }
      return false;
    }

    function handleIdleState(e, sprites) {
      e.frame += 0.05;
      if (e.frame >= sprites.length) e.frame = 0;

      // Use "idle" frames (0–3) only for idle state
      const { frame } = getAnimationFrame(e, sprites);
      e.frame = frame;

      e.rotation = 0; // Ensure the enemy points upward in idle state
      e.x = e.originX + waveOffsetX;
      e.y = e.originY;
    }

    function handleExplodeState(e, index, sprites) {
      e.frame += 0.4;
      if (e.frame >= sprites.length) {
        // Marker fienden som død i formasjonen
        const formationEnemy = formation.find(f => f.x === e.originX && f.y === e.originY);
        if (formationEnemy) formationEnemy.dead = true;

        enemyGrid.splice(index, 1);
        return true;
      }
      return false;
    }

    function drawEnemy(e) {
      const sprites = enemySprites[e.type]?.[e.state] || enemySprites[e.type]?.idle;
      if (!sprites || sprites.length === 0 || typeof e.frame !== 'number') return;
      const sprite = sprites[Math.floor(e.frame) % sprites.length];

      ctx.save();
      ctx.translate(e.x + enemySize / 2, e.y + enemySize / 2);
      ctx.rotate(e.rotation || 0); // Rotate to align with movement direction
      if (e.flipH) ctx.scale(-1, 1); // Flip horizontally
      ctx.translate(-enemySize / 2, -enemySize / 2);
      ctx.drawImage(spriteSheet, sprite.x, sprite.y, sprite.w, sprite.h, 0, 0, enemySize, enemySize);
      ctx.restore();
    }

    function checkCollisions() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        for (let j = enemyGrid.length - 1; j >= 0; j--) {
          const e = enemyGrid[j];
          if (e.state === 'explode') continue;
          if (b.x < e.x + enemySize && b.x + 4 > e.x && b.y < e.y + enemySize && b.y + 20 > e.y) {
            bullets.splice(i, 1);
            e.state = 'explode';
            e.frame = 0;
            return;
          }
        }
      }
    }

    function drawBullets() {
      ctx.fillStyle = 'white';
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= bullets[i].speed;
        if (bullets[i].y < 0) bullets.splice(i, 1);
        else ctx.fillRect(bullets[i].x, bullets[i].y, 4, 20);
      }
    }

    function drawPlayer() {
      ctx.drawImage(spriteSheet, playerSprite.x, playerSprite.y, playerSprite.w, playerSprite.h, player.x, player.y, player.width, player.height);
    }

    function drawParticles() {
      for (let p of particles) {
        p.y -= p.dy; // Move particles upward
        if (p.y < 0) p.y = h; // Recycle particles that go off the top
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
      }
    }

    function updatePlayer() {
      if (keys['ArrowLeft']) player.x -= player.speed;
      if (keys['ArrowRight']) player.x += player.speed;
      player.x = Math.max(0, Math.min(player.x, w - player.width));
    }

    function animate() {
      ctx.clearRect(0, 0, w, h);
      tick++;
      waveOffsetX += waveDir;
      if (waveOffsetX > 40 || waveOffsetX < -40) waveDir *= -1;
      drawParticles();
      updatePlayer();
      drawPlayer();
      drawEnemies();
      drawBullets();
      checkCollisions();
      checkAllEnemiesShot();
      requestAnimationFrame(animate);
    }

    function generateParticles() {
      particles = [];
      for (let i = 0; i < numParticles; i++) {
        const rand = Math.random();
        particles.push({
          x: Math.random() * w,
          y: Math.random() * h,
          r: rand < 0.7 ? Math.random() * 0.6 + 0.3 : Math.random() * 2 + 1,
          dx: 0, // No horizontal movement
          dy: Math.random() * 0.5 + 0.2 // Vertical movement upward
        });
      }
    }

    function resize() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
      player.y = h - player.height - 10;
      generateParticles();
      flyInEnemies();
    }

    function checkAllEnemiesShot() {
      if (enemyGrid.length === 0) setTimeout(flyInEnemies, 1000);
    }

    function flyInEnemies() {
      enemyGrid.length = 0;
      formation = []; // Reset formation
      const usedPositions = new Set(); // Keep track of positions already used
      const startX = (w - spacing * 10) / 2;

      for (let col = 2; col < 8; col++) formation.push({ type: 'red', x: startX + col * spacing, y: 100, dead: false });
      for (let col = 1; col < 9; col++) formation.push({ type: 'purple', x: startX + col * spacing, y: 164, dead: false });
      for (let row = 2; row < 5; row++)
        for (let col = 0; col < 10; col++) formation.push({ type: 'blue', x: startX + col * spacing, y: 100 + row * spacing, dead: false });
      [3, 6].forEach(col => formation.push({ type: 'yellow', x: startX + col * spacing, y: 36, dead: false }));

      formation.forEach((enemy, i) => {
        if (enemy.dead) return; // Skip dead enemies
        const key = `${enemy.x},${enemy.y}`;
        if (usedPositions.has(key)) return; // Avoid double spawning
        usedPositions.add(key);

        setTimeout(() => {
          // Check if the enemy already exists in enemyGrid
          if (!enemyGrid.some(e => e.originX === enemy.x && e.originY === enemy.y)) {
            enemyGrid.push({
              type: enemy.type,
              x: enemy.x,
              y: -enemySize,
              originX: enemy.x,
              originY: enemy.y,
              state: 'enter',
              frame: 0,
              t: 0,
              direction: Math.random() < 0.5 ? 'left' : 'right',
              flyAmp: 150 + Math.random() * 100,
              flyFreq: 1 + Math.random(),
              wasAttacking: false
            });
          }
        }, i * 80);
      });

      setTimeout(() => { enemiesCanAttack = true }, 2500);
    }

    setInterval(() => {
      if (!enemiesCanAttack) return;

      // Find the first idle yellow enemy
      const yellow = enemyGrid.find(e => e.type === 'yellow' && e.state === 'idle');
      if (yellow) {
        // Select the two closest idle red enemies to the yellow enemy
        const escorts = enemyGrid
          .filter(e => e.type === 'red' && e.state === 'idle')
          .sort((a, b) => Math.abs(a.originX - yellow.originX) - Math.abs(b.originX - yellow.originX))
          .slice(0, 2); // Pick the two closest red enemies

        if (escorts.length === 2) {
          // Set the yellow enemy and its escorts to attack
          [yellow, ...escorts].forEach((e, i) => {
            e.state = 'fly';
            e.t = 0;
            e.frame = 0;
            e.wasAttacking = true;
            e.flyAmp = 150 + Math.random() * 100;
            e.flyFreq = 1 + Math.random();
            e.direction = yellow.originX < w / 2 ? 'left' : 'right';

            // Mark escorts to follow this yellow enemy
            if (i > 0) { // Only adjust escorts (not the yellow enemy)
              e.followYellow = yellow; // Reference the yellow enemy they follow
              e.offsetX = (i === 1 ? -spacing : spacing); // Position left or right of the yellow enemy
              e.offsetY = 40; // Slightly below the yellow enemy
            }
          });
          return; // Ensure only one yellow enemy attacks at a time
        }
      }
    }, 2000);

    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => {
      keys[e.code] = false;
      if (e.code === 'Space' && bullets.length < 1) {
        bullets.push({ x: player.x + player.width / 2 - 2, y: player.y - 10, speed: 5 });
      }
    });

    window.addEventListener('resize', resize);
    spriteSheet.onload = () => {
      resize();
      animate();
    };
  </script>
</body>
</html>