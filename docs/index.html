<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>falch.me - Galaxian</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      height: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>
  <script>
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    let w, h;

    const spriteSheet = new Image();
    spriteSheet.src = 'sprites.png';

    const player = { x: 100, y: 0, width: 64, height: 64, speed: 4 };
    const playerSprite = { x: 1, y: 69, w: 16, h: 17 };
    const keys = {};
    const bullets = [];
    const enemyGrid = [];
    const spacing = 64;
    const enemySize = 64;
    const numParticles = 250;
    let particles = [];
    let tick = 0;
    let waveOffsetX = 0;
    let waveDir = 1;
    let enemiesCanAttack = false;
    let formation = []; 
    
    const enemySprites = {
      red: generateSprites({ x: 1, y: 1 }, 4, 6),
      blue: generateSprites({ x: 1, y: 35 }, 4, 6),
      purple: generateSprites({ x: 1, y: 18 }, 4, 6),
      flagship: {
        idle: [{ x: 1, y: 52, w: 16, h: 16 }],
        fly: Array.from({ length: 6 }, (_, i) => ({ x: 18 + i * 17, y: 52, w: 16, h: 16 })),
        explode: [61, 78, 95, 112].map(x => ({ x, y: 70, w: 16, h: 16 }))
      }
    };

    function generateSprites(start, idleCount, flyCount) {
      const spriteWidth = 16, spriteHeight = 16;
      const explode = [61, 78, 95, 112].map(x => ({ x, y: 70, w: spriteWidth, h: spriteHeight }));
      const idle = Array.from({ length: idleCount }, (_, i) => ({ x: start.x + i * 17, y: start.y, w: spriteWidth, h: spriteHeight }));
      const fly = Array.from({ length: flyCount }, (_, i) => ({ x: start.x + (idleCount + i) * 17, y: start.y, w: spriteWidth, h: spriteHeight }));
      return { idle, explode, fly };
    }

    function drawEnemies() {
      for (let i = enemyGrid.length - 1; i >= 0; i--) {
        const e = enemyGrid[i];
        if (updateEnemyState(e, i)) continue;
        drawEnemy(e);
      }
    }

    function updateEnemyState(e, index) {
      const sprites = enemySprites[e.type][e.state] || enemySprites[e.type].idle;
      switch (e.state) {
        case 'fly':
          return handleFlyState(e, index, sprites);
        case 'return':
          return handleReturnState(e, sprites);
        case 'enter':
          return handleEnterState(e, sprites);
        case 'idle':
          handleIdleState(e, sprites);
          break;
        case 'explode':
          return handleExplodeState(e, index, sprites);
      }
      return false;
    }

    function getAnimationFrame(e, sprites) {
      const dx = e.x - e.prevX;
      const dy = e.y - e.prevY;

      if (e.state === 'idle') {
        // Use "idle" frames (0–3) only for idle state
        return { frame: Math.floor((tick / 5) % 4), flipH: false, flipV: false };
      } else if (e.state === 'explode') {
        // Use explosion frames
        return { frame: Math.floor(e.frame), flipH: false, flipV: false };
      }

      // Map the angle of movement to the appropriate frame
      const angle = Math.atan2(dy, dx);
      let frame = 4; // Default to the first flight frame
      let flipH = false;

      if (angle >= -Math.PI / 4 && angle < Math.PI / 4) {
        // Moving right
        frame = 4;
      } else if (angle >= Math.PI / 4 && angle < (3 * Math.PI) / 4) {
        // Moving down (prioritize downward attack direction)
        frame = 6;
      } else if (angle >= (3 * Math.PI) / 4 || angle < -(3 * Math.PI) / 4) {
        // Moving left
        frame = 4;
        flipH = true;
      } else if (angle >= -(3 * Math.PI) / 4 && angle < -Math.PI / 4) {
        // Moving up
        frame = 6;
      }

      return { frame, flipH, flipV: false }; // Ensure no vertical flipping
    }

    let currentWave = 1;
    let attackDelay = computeAttackDelay(currentWave);
    let maxSimultaneousAttackers = computeMaxAttackers(currentWave);
    let activeAttackers = 0;

    function computeAttackDelay(wave) {
      return Math.max(2000 - wave * 100, 500); // Decrease delay with wave, minimum 500ms
    }

    function computeMaxAttackers(wave) {
      return Math.min(1 + Math.floor(wave / 3), 3); // Increase attackers every 3 waves, max 3
    }

    function computeEnemySpeed(wave) {
      return 2 + wave * 0.2; // Increase speed slightly with each wave
    }

    // Modify enemy speed dynamically
    function handleFlyState(e, index, sprites) {
      e.t += 0.02;

      e.prevX = e.x;
      e.prevY = e.y;

      const speed = computeEnemySpeed(currentWave); // Adjust speed based on wave
      e.y += speed;

      if (e.type === 'flagship') {
        // Flagship leads the attack with a swooping motion
        const dir = e.direction === 'left' ? -1 : 1;
        e.x = e.originX + dir * Math.sin(e.t * e.flyFreq * Math.PI) * e.flyAmp;
        e.y += 1.5; // Move downward

        const { frame, flipH, flipV } = getAnimationFrame(e, sprites);
        e.frame = frame;
        e.flipH = flipH;
        e.flipV = flipV;

        e.rotation = Math.atan2(e.y - e.prevY, e.x - e.prevX);

        // Update the positions of the red escorts following this flagship
        const escorts = enemyGrid.filter(escort => escort.followFlagship === e && escort.state === 'fly');
        escorts.forEach((escort, i) => {
          escort.x = e.x + (i === 0 ? -spacing : spacing); // Position escorts on either side
          escort.y = e.y + 40; // Slightly below the flagship
          escort.rotation = e.rotation; // Match flagship's rotation
        });

        if (e.y > h + enemySize) {
          // Transition to "return" state and reset position above the screen
          e.state = 'return';
          e.y = -enemySize;
          e.x = e.originX;
          e.wasAttacking = false;

          // Reset escorts to their original positions
          escorts.forEach(escort => {
            escort.state = 'return';
            escort.wasAttacking = false;
            escort.followFlagship = null; // Remove reference to the flagship
            escort.y = -enemySize; // Start from above the screen
          });
          return true;
        }

        return false;
      }

      if (e.followFlagship) {
        // Dynamically follow the flagship
        const flagship = e.followFlagship;
        if (flagship && flagship.state === 'fly') {
          e.x = flagship.x + e.offsetX; // Follow flagship's x position with offset
          e.y = flagship.y + e.offsetY; // Follow flagship's y position with offset
          e.rotation = flagship.rotation; // Match flagship's rotation
        }
        return false;
      }

      // Handle other enemy types
      const dir = e.direction === 'left' ? -1 : 1;
      e.x = e.originX + dir * Math.sin(e.t * e.flyFreq * Math.PI) * e.flyAmp;
      e.y += 2;

      const { frame, flipH, flipV } = getAnimationFrame(e, sprites);
      e.frame = frame;
      e.flipH = flipH;
      e.flipV = flipV;

      e.rotation = Math.atan2(e.y - e.prevY, e.x - e.prevX);

      if (e.y > h + enemySize) {
        e.state = 'return';
        e.y = -enemySize;
        e.x = e.originX;
        e.wasAttacking = false;
        return true;
      }

      return false;
    }

    function startReturn(e) {
      e.state = 'return';
      e.wasAttacking = false;
    }

    function handleReturnState(e, sprites) {
      if (tick % 4 === 0) e.frame = (e.frame + 1) % sprites.length;

      // Interpolate back to formation position
      const dx = (e.originX - e.x) * 0.1;
      const dy = (e.originY - e.y) * 0.1;
      e.x += dx;
      e.y += dy;

      // Snap to "idle" state when close to formation position
      if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
        e.x = e.originX;
        e.y = e.originY;
        e.state = 'idle';
        e.frame = 0;
        e.rotation = 0; // Reset rotation
      }
      return false;
    }

    function handleEnterState(e, sprites) {
      if (tick % 3 === 0) e.frame = (e.frame + 1) % sprites.length;
      e.t += 0.04;
      e.x = e.originX + Math.sin(e.t * 2) * 150;
      e.y = -100 + e.t * 100;
      if (e.y >= e.originY) {
        e.y = e.originY;
        e.x = e.originX;
        e.state = 'idle';
        e.frame = 0;
      }
      return false;
    }

    function handleIdleState(e, sprites) {
      e.frame += 0.05;
      if (e.frame >= sprites.length) e.frame = 0;

      // Use "idle" frames (0–3) only for idle state
      const { frame } = getAnimationFrame(e, sprites);
      e.frame = frame;

      e.rotation = 0; // Ensure the enemy points upward in idle state
      e.x = e.originX + waveOffsetX;
      e.y = e.originY;
    }

    function handleExplodeState(e, index, sprites) {
      e.frame += 0.4;
      if (e.frame >= sprites.length) {
        // Marker fienden som død i formasjonen
        const formationEnemy = formation.find(f => f.x === e.originX && f.y === e.originY);
        if (formationEnemy) formationEnemy.dead = true;

        enemyGrid.splice(index, 1);
        return true;
      }
      return false;
    }

    function drawEnemy(e) {
      const sprites = enemySprites[e.type]?.[e.state] || enemySprites[e.type]?.idle;
      if (!sprites || sprites.length === 0 || typeof e.frame !== 'number') return;
      const sprite = sprites[Math.floor(e.frame) % sprites.length];

      ctx.save();
      ctx.translate(e.x + enemySize / 2, e.y + enemySize / 2);
      ctx.rotate(e.rotation || 0); // Rotate to align with movement direction
      if (e.flipH) ctx.scale(-1, 1); // Flip horizontally
      ctx.translate(-enemySize / 2, -enemySize / 2);
      ctx.drawImage(spriteSheet, sprite.x, sprite.y, sprite.w, sprite.h, 0, 0, enemySize, enemySize);
      ctx.restore();
    }

    function checkCollisions() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        for (let j = enemyGrid.length - 1; j >= 0; j--) {
          const e = enemyGrid[j];
          if (e.state === 'explode') continue;
          if (b.x < e.x + enemySize && b.x + 4 > e.x && b.y < e.y + enemySize && b.y + 20 > e.y) {
            bullets.splice(i, 1);
            e.state = 'explode';
            e.frame = 0;
            return;
          }
        }
      }
    }

    function drawBullets() {
      ctx.fillStyle = 'white';
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= bullets[i].speed;
        if (bullets[i].y < 0) bullets.splice(i, 1);
        else ctx.fillRect(bullets[i].x, bullets[i].y, 4, 20);
      }
    }

    function drawPlayer() {
      ctx.drawImage(spriteSheet, playerSprite.x, playerSprite.y, playerSprite.w, playerSprite.h, player.x, player.y, player.width, player.height);
    }

    function drawParticles() {
      for (let p of particles) {
        p.y -= p.dy; // Move particles upward
        if (p.y < 0) p.y = h; // Recycle particles that go off the top
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
      }
    }

    function updatePlayer() {
      if (keys['ArrowLeft']) player.x -= player.speed;
      if (keys['ArrowRight']) player.x += player.speed;
      player.x = Math.max(0, Math.min(player.x, w - player.width));
    }

    function animate() {
      ctx.clearRect(0, 0, w, h);
      tick++;
      waveOffsetX += waveDir;
      if (waveOffsetX > 40 || waveOffsetX < -40) waveDir *= -1;
      drawParticles();
      updatePlayer();
      drawPlayer();
      drawEnemies();
      drawBullets();
      checkCollisions();
      checkAllEnemiesShot();
      requestAnimationFrame(animate);
    }

    function generateParticles() {
      particles = [];
      for (let i = 0; i < numParticles; i++) {
        const rand = Math.random();
        particles.push({
          x: Math.random() * w,
          y: Math.random() * h,
          r: rand < 0.7 ? Math.random() * 0.6 + 0.3 : Math.random() * 2 + 1,
          dx: 0, // No horizontal movement
          dy: Math.random() * 0.5 + 0.2 // Vertical movement upward
        });
      }
    }

    function resize() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
      player.y = h - player.height - 10;
      generateParticles();
      flyInEnemies();
    }

    function startNextWave() {
      currentWave++;
      attackDelay = computeAttackDelay(currentWave);
      maxSimultaneousAttackers = computeMaxSimultaneousAttackers(currentWave);
      flagshipCooldown = 0; // Reset flagship cooldown for the new wave
      flyInEnemies();
    }

    function checkAllEnemiesShot() {
      if (enemyGrid.length === 0) setTimeout(startNextWave, 1000);
    }

    let gameStarted = false; // Flag to ensure the game starts only once

    function startGame() {
      if (gameStarted) return; // Prevent double initialization
      gameStarted = true;

      resize(); // Set up canvas dimensions and initial state
      flyInEnemies(); // Initialize enemies
      animate(); // Start the game loop
    }

    function flyInEnemies() {
      enemyGrid.length = 0; // Clear existing enemies
      formation = []; // Reset formation
      const usedPositions = new Set(); // Keep track of positions already used
      const startX = (w - spacing * 10) / 2;

      for (let col = 2; col < 8; col++) formation.push({ type: 'red', x: startX + col * spacing, y: 100, dead: false });
      for (let col = 1; col < 9; col++) formation.push({ type: 'purple', x: startX + col * spacing, y: 164, dead: false });
      for (let row = 2; row < 5; row++)
        for (let col = 0; col < 10; col++) formation.push({ type: 'blue', x: startX + col * spacing, y: 100 + row * spacing, dead: false });
      [3, 6].forEach(col => formation.push({ type: 'flagship', x: startX + col * spacing, y: 36, dead: false }));

      formation.forEach((enemy, i) => {
        if (enemy.dead) return; // Skip dead enemies
        const key = `${enemy.x},${enemy.y}`;
        if (usedPositions.has(key)) return; // Avoid double spawning
        usedPositions.add(key);

        setTimeout(() => {
          // Check if the enemy already exists in enemyGrid
          if (!enemyGrid.some(e => e.originX === enemy.x && e.originY === enemy.y)) {
            enemyGrid.push({
              type: enemy.type,
              x: enemy.x,
              y: -enemySize,
              originX: enemy.x,
              originY: enemy.y,
              state: 'enter',
              frame: 0,
              t: 0,
              direction: Math.random() < 0.5 ? 'left' : 'right',
              flyAmp: 150 + Math.random() * 100,
              flyFreq: 1 + Math.random(),
              wasAttacking: false
            });
          }
        }, i * 80);
      });

      setTimeout(() => { enemiesCanAttack = true }, 2500);
    }

    // Ensure the game starts only once when the sprite sheet is loaded
    spriteSheet.onload = startGame;

    // Prevent resize from restarting the game
    window.addEventListener('resize', resize);

    let flagshipCooldown = 0; // Cooldown-timer for flagships
    const maxFlagshipAttacksPerWave = 3; // Maks antall flagship-angrep per bølge

    const MAX_SIMULTANEOUS_ATTACKERS = 2;
    const ATTACK_PROBABILITY = {
      red: 0.02,    // 2% per frame
      purple: 0.008, // 0.8% per frame
      blue: 0.003   // 0.3% per frame
    };
    const FLAGSHIP_ATTACK_PROBABILITY = 0.005; // 0.5% per frame

    function computeAttackProbability(wave) {
      return {
        red: 0.02 + wave * 0.002,    // Increase by 0.2% per wave
        purple: 0.008 + wave * 0.001, // Increase by 0.1% per wave
        blue: 0.003 + wave * 0.0005   // Increase by 0.05% per wave
      };
    }

    function computeMaxSimultaneousAttackers(wave) {
      return Math.min(2 + Math.floor(wave / 5), 5); // Increase by 1 every 5 waves, max 5
    }

    setInterval(() => {
      if (!enemiesCanAttack) return;

      activeAttackers = enemyGrid.filter(e => e.state === 'fly').length;

      const attackProbability = computeAttackProbability(currentWave);
      const maxAttackers = computeMaxSimultaneousAttackers(currentWave);

      if (activeAttackers >= maxAttackers) return;

      // Try triggering flagship attack
      tryTriggerFlagshipAttack();

      // Try triggering solo attacks for other enemies
      tryTriggerSoloAttacks(attackProbability);
    }, attackDelay);

    function tryTriggerFlagshipAttack() {
      const flagship = enemyGrid.find(e => e.type === 'flagship' && e.state === 'idle');
      if (!flagship || Math.random() >= FLAGSHIP_ATTACK_PROBABILITY) return;

      let escorts = enemyGrid
        .filter(e => e.type === 'red' && e.state === 'idle')
        .slice(0, 2); // Max 2 red escorts

      if (escorts.length < 2) {
        escorts = enemyGrid
          .filter(e => e.type === 'purple' && e.state === 'idle')
          .slice(0, 2); // Max 2 purple escorts
      }

      [flagship, ...escorts].forEach((e, i) => {
        e.state = 'fly';
        e.t = 0;
        e.frame = 0;
        e.wasAttacking = true;
        e.flyAmp = 150 + Math.random() * 100;
        e.flyFreq = 1 + Math.random();
        e.direction = flagship.originX < w / 2 ? 'left' : 'right';

        if (i > 0) {
          e.followFlagship = flagship; // Reference the flagship they follow
          e.offsetX = (i === 1 ? -spacing : spacing); // Position left or right of the flagship
          e.offsetY = 40; // Slightly below the flagship
        }
      });

      activeAttackers += escorts.length + 1; // Update active attackers
    }

    function tryTriggerSoloAttacks(attackProbability) {
      const idleEnemies = pickIdleEnemiesInPriorityOrder();

      for (const enemy of idleEnemies) {
        if (enemy.type === 'red' && Math.random() < attackProbability.red) {
          startSoloDive(enemy);
          return;
        }

        if (enemy.type === 'purple' && Math.random() < attackProbability.purple) {
          startSoloDive(enemy);
          return;
        }

        if (enemy.type === 'blue' && Math.random() < attackProbability.blue) {
          startSoloDive(enemy);
          return;
        }
      }
    }

    function pickIdleEnemiesInPriorityOrder() {
      const red = enemyGrid.filter(e => e.type === 'red' && e.state === 'idle');
      const purple = enemyGrid.filter(e => e.type === 'purple' && e.state === 'idle');
      const blue = enemyGrid.filter(e => e.type === 'blue' && e.state === 'idle');
      return [...red, ...purple, ...blue];
    }

    function startSoloDive(enemy) {
      enemy.state = 'fly';
      enemy.t = 0;
      enemy.frame = 0;
      enemy.direction = Math.random() < 0.5 ? 'left' : 'right';
      enemy.flyFreq = 1 + Math.random();
      enemy.wasAttacking = true;

      activeAttackers++; // Update active attackers
    }

    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => {
      keys[e.code] = false;
      if (e.code === 'Space' && bullets.length < 1) {
        bullets.push({ x: player.x + player.width / 2 - 2, y: player.y - 10, speed: 5 });
      }
    });

    window.addEventListener('resize', resize);
  </script>
</body>
</html>